import torch
import torch.nn as nn
import torch.optim as optim
import torchvision.models as models
import torchvision.transforms as transforms
from torch.utils.data import DataLoader
from data_preprocessing import Data, train_images, train_labels, val_images, val_labels
from PIL import Image

device = torch.device("mps")
class_list = ["empty", "person", "vehicle"]

# Transforms for images
pic_transform = transforms.Compose([transforms.Resize((224, 224)),
                                    transforms.ToTensor(),
                                    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])


# Step 1: Initialise ResNet-18 with pre-trained weights as a feature extractor
# Modify full connected(fc) layer with nn.Linear for 3-class classification
def get_shipWatcher():
    model = models.resnet18(weights="DEFAULT")
    for param in model.parameters():
        param.requires_grad = False
    input_size = model.fc.in_features
    model.fc = nn.Linear(input_size,3)
    return model


# Define function for training, validating shipWatcher model with certain hyperparameters
def prepare_and_train(epochs, lr, weight_decay, betas):
    shipWatcher = get_shipWatcher()
    shipWatcher = shipWatcher.to(device)
    criterion = nn.CrossEntropyLoss()
    optimiser = optim.Adam(shipWatcher.fc.parameters(), lr=lr, weight_decay=weight_decay, betas=betas)
    train_dataset = Data([train_images, train_labels], transform=pic_transform)
    val_dataset = Data([val_images, val_labels], transform=pic_transform)
    train_loader = DataLoader(dataset=train_dataset, batch_size=5, shuffle=True)
    val_loader = DataLoader(dataset=val_dataset, batch_size=len(val_images))

    for epoch in range(epochs):
        shipWatcher.train()
        train_loss = 0
        val_accuracy = 0
        print("_________________")
        print(f"Epoch {epoch+1}")
        for x, y in train_loader:
            x = x.to(device)
            y = y.to(device)
            optimiser.zero_grad()
            yhat = shipWatcher(x)
            loss = criterion(yhat, y)
            loss.backward()
            optimiser.step()
            train_loss += loss.item()
        print(f"Training Loss: {train_loss}")
        shipWatcher.eval()
        with torch.no_grad():
            for x, y in val_loader:
                x = x.to(device)
                y = y.to(device)
                yhat = shipWatcher(x)
                val_accuracy = (torch.argmax(yhat, dim=1)==y).sum().item()
                print(f"{val_accuracy}/{len(val_images)}")

